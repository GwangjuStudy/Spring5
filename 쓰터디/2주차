Component scan

- 자동 주입과 함께 사용하는 추가 기능이 component scan이다.
- 스프링이 직접 클래스를 검색해서 bean으로 등록해주는 기능이다.
- bean 설정에 등록하지 않아도 원하는 클래스를 bean으로 등록할 수 있어 component scan을 사용하면 bean 설정 코드가 많이 줄어든다.

컴포넌트 스캔의 등록

1) @Component 으로 스캔 대상 지정

- 서비스 코드에 붙인다.

```
@Component
public class MemberDao {
//..
}
```

이렇게 되면 bean이름은 “memberDao”로 자동지정된다. 자동 지정 규칙은 camelCase다.

아래와 같이 속성을 줄 수 있다

```
@Component("memberRepository")
public class MemberDao {
//..
}
```

속성을 지정하면 해당 이름으로 변경된다.

2) @ComponentScan 으로 스캔 설정

-bean 설정 코드에 아래와 같이 추가한다.

```
@Configuration
@ComponentScan(basePackages = {"student"}) // <<< sudent패키지 하위의 클래스를 스캔 대상으로 한다.
public class AppContext {
    //...
}
```

컴포넌트로 등록하면 bean설정 코드가 많이 줄어든다.

3) getBean()의 변경

- 컴포넌트로 bean 생성을 지정하게 되면 camelCase 이름을 가진다.
- 컴포넌트 스캔을 사용하고자 한다면, 기존의 getBean 메소드에서 bean 객체를 불러올때 설정한 닉네임을 없애거나 컴포넌트 속성의 값으로 맞춰야 한다.

// before (아무 속성을 주지 않았을때)

```
    MemberRegisterService regSvc = 
                ctx.getBean("memberRegSvc", MemberRegisterService.class);
//after
MemberRegisterService regSvc = 
                ctx.getBean(MemberRegisterService.class);

```

스캔 대상의 필터링 (포함하기, 제외하기)

1) @ComponentScan(excludeFilters)

- 특정 bean 객체를 자동 등록 대상에서 제외할 수 있다.

a. 정규식 패턴

```
@Configuration
@ComponentScan(basePackages = {"spring", "spring2" }, 
    excludeFilters = { 
            @Filter(type = FilterType.REGEX, pattern = "spring\\..*Dao")            
})
public class AppCtxWithExclude {
    //..
```

- 정규표현식으로 패턴으로 컴포넌트 스캔 대상을 필터링 한다.
- 위의 패턴은 spring. 으로 시작하고 Dao로 끝나는 클래스를 필터링 한다.

b. AspectJ 패턴

```
@Configuration
@ComponentScan(basePackages = {"spring", "spring2" }, 
    excludeFilters = { 
            @Filter(type = FilterType.ASPECTJ, pattern = "spring.*Dao")         
})
public class AppCtxWithExclude {
AspectJ 패턴은 정규식과 약간 다르다.
pattern은 String[] 타입이라 한개 이상 지정할 수 있다
작동하려면 maven에 AspectJ를 추가해야한다.
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.8.13</version>
</dependency>
```

c. 어노테이션 패턴

- 특정 어노테이션을 붙이면 제외되도록 할 수 있다.
- 먼저 아래와 같이 어노테이션을 만든다.

```
//ManualBean.class
@Retention(RUNTIME)
@Target(TYPE)
public @interface ManualBean {

}
```

 - 그 다음 컴포넌트 스캔 설정의 필터에 아래와 같이 추가하면 된다.
- 여러개의 어노테이션 등록도 가능하다 {class1,class2}

```
@Configuration
@ComponentScan(basePackages = {"spring", "spring2" }, 
    excludeFilters = { 
            @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class )          
})
public class AppCtxWithExclude {
    //...

```

d. Assignable_type 패턴

```
@Configuration
@ComponentScan(basePackages = {"spring", "spring2" }, 
    excludeFilters = { 
            @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MemberDao.class )          
})
public class AppCtxWithExclude {
    //...
```

- 위와 같이 클래스 자체를 지정해서 제외할 수도 있다.
- 기본 스캔 대상
- 스프링에서 @Component 이외에 스캔대상으로 자동 편입하는 어노테이션이 몇가지 더 있다

@Component
@Controller
@Service
@Repository
@Aspect
@Configuration

컴포넌트 충돌 T/S

1) bean 이름 충돌

- 컴포넌트 스캔을 여러개 하는 경우 같은 클래스를 등록하려는 경우가 있는데 이럴때는 명시적으로 이름을 등록해야한다 getBean()

2) 수동 등록한 bean과 충돌

- bean 등록시 수동으로 명시한 bean을 우선순위로 등록한다.
- 같은 객체를 바라보는 경우는 @Qualifier로 알맞은 bean을 선택해야 한다.


==========================================================================================================================================

Bean Lifecycle

- 스프링 컨테이너를 초기화하고 종료할 때는 다음 작업을 수행한다.
- 컨테이너 초기화 → bean 객체의 생성, 의존 주입, 초기화
- 컨테이너 종료 → bean 객체의 소멸
- 초기화와 소멸의 bean 인터페이스

```
InitializingBean
public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
```

- bean객체가 생성 된 뒤 InitializingBean 클래스의 afterPropertiesSet() 메소드가 호출된다.
- 초기화 직후 필요한 작업이 있다면 이 클래스를 구현하면 된다.

```
DisposableBean
public interface DisposableBean {
    void destroy() throws Exception;
}
```

- bean객체가 소멸할때 close()로 호출하는데 이 호출되는 과정에서 DisposableBean 클래스의 destroy()가 호출된다.
- 소멸 과정에서 필요한 작업이 있다면 이 클래스를 구현하면 된다.

그래서 언제 필요한가

- 데이터베이스 커넥션 풀의 연결과 연결해제.
- 채팅 프로그램의 서버 연결과 연결해제.

실제

1. 연결과 해제를 담당하는 구현체

```
public class Client implements InitializingBean, DisposableBean {

    private String host;

    public void setHost(String host) {
        this.host = host;
    }

    @Override
    public void afterPropertiesSet() throws Exception { // <<<<
        System.out.println("Client.afterPropertiesSet() 실행");
    }

    public void send() {
        System.out.println("Client.send() to " + host);
    }

    @Override
    public void destroy() throws Exception { // <<<< 
        System.out.println("Client.destroy() 실행");
    }

}
```

2. bean 설정

```
@Configuration
public class AppCtx {

    @Bean
    public Client client() {
        Client client = new Client();
        client.setHost("host");
        return client;
    }
}
```

3. 스프링 실행

```
    public static void main(String[] args) throws IOException {
        AbstractApplicationContext ctx = 
                new AnnotationConfigApplicationContext(AppCtx.class);

        Client client = ctx.getBean(Client.class);
        client.send();

        ctx.close();
    }
```

4. 실행 후 콘솔 결과

```
Client.afterPropertiesSet() 실행
Client.send() to host
Client.destroy() 실행
```

- 처음 설명대로 생성 뒤에 afterProperties()가 바로 실행되고 close()뒤에 destroy()가 실행 된다.

- 초기화와 소멸의 bean 인터페이스 커스텀
- 직접 구현한 클래스가 아닌 외부에서 받은 소스의 경우 InitializingBean과 DisposableBean 인터페이스의 구현체를 만들 수 없다.
- 또한 외부의 소스에서 두 인터페이스를 구현해야하는데 사용하고 싶지 않은 경우도 있을 수 있다.

1. 일반적인 서비스 코드

```
public class Client2 {

    private String host;

    public void setHost(String host) {
        this.host = host;
    }

    public void connect() {
        System.out.println("Client2.connect() 실행");
    }

    public void send() {
        System.out.println("Client2.send() to " + host);
    }

    public void close() {
        System.out.println("Client2.close() 실행");
    }

}
```

2. bean 설정

```
@Configuration
public class AppCtx {
    @Bean(initMethod = "connect", destroyMethod = "close")
    public Client2 client2() {
        Client2 client = new Client2();
        client.setHost("host");
        return client;
    }
}
```

bean 어노테이션에 initMethod와 destroyMethod를 명시하고 bean객체가 초기화 되고 소멸할때 사용할 메소드 이름을 입력해주면 된다.

3. 실행

```
Client2.connect() 실행
Client2.send() to host
Client2.close() 실행
```

마찬가지로 실행된다.

===================================================================================================================================

Prototype

- 스프링 컨테이너는 기본적으로 bean객체를 생성 할 떄 싱글톤으로 생성한다.
- 그러나 여러개의 인스턴스가 필요한 경우 prototype으로 scope를 지정하면 된다.
- 프로토타입 범위 지정
bean설정에서 scope에 속성으로 지정하면 된다.

```
    @Bean
    @Scope("prototype") // <<<<<
    public Client client() {
        Client client = new Client();
        client.setHost("host");
        return client;
    }
```

그리고 아래 코드를 실행 하면 false가 반환된다.

```
        Client client1 = ctx.getBean(Client.class);
        Client client2 = ctx.getBean(Client.class);
        System.out.println("client1 == client2 : " + (client1 == client2));
```

프로토타입 주의사항

- 프로토타입 범위를 갖는 bean은 완전한 라이프사이클을 따르지 ㅇ낳는다.
- 컨테이너 생성시 초기화 작업까지는 하지만 컨테이너 를 소멸하는 close() 작업시 bean객체의 destroy()를 실행하지 않는다.
- 그래서 프로토타입 bean을 사용할때는 소멸 코드를 꼭 관리해야한다.

===========================================================================================================================================

- 스프링에서 프록시 패턴을 어떻게 적용시키는지 실제로 스프링을 통해 적용해본다.
- proxy 패턴은 decorator 객체 로도 활용할 수 있다. 기능 추가와 확장에 초점이 맞춰져있다.

짤막한 프록시의 핵심

- 프록시의 특징은 핵심 기능은 구현하지 않는다는 점이다.
- 프록시는 핵심 기능을 구현하지 않는 대신 여러 객체에 공통으로 적용할 수 있는 기능을 구현한다.
- AOP의 기본 핵심은 공통 기능을 삽입하는 것 이다.

AOP의 주요 용어

1. Advice

- 공통 관심 기능을 핵심 로직에 적용하는 시점을 정의한다.
- ex) 메소드를 호출하기 전에 트랜잭션을 시작하는 기능을 적용한다.

2. Joinpoint

- Advice를 적용하는 지점을 의미한다.
- 메소드 호출, 필드 값 변경 등을 포함한다.
- 스프링은 메소드 호출에 대한 Joinpoint만 지원

3. Pointcut

- Advice가 실제 적용되는 Joinpoint를 의미한다.
- 스프링에서는 정규표현식이나 AspectJ의 문법을 이용해 Poincut을 정의한다.

4. Weaving

- Advice를 핵심 로직 코드에 적용하는 행위.

5. Aspect

- 여러 객체에 공통으로 적용되는 기능을 Aspect라고 한다.

Aspect의 종류

- 스프링에서 구현 가능한 Aspect의 종류
 1) Before Advice : 메소드 호출 전 Aspect를 실행한다.
 2) After Returning Advice : 메소드가 Exception 없이 실행 된 이후 Aspect를 실행한다.
 3) After Throwing Advice : 메소드가 Exception 이 발생한 경우 Aspect를 실행한다.
 4) After Advice : Exception 상관 없이 메소드 실행 후 Aspect를 실행한다.
 5) Around Advice : 메소드 실행 전, 후, Exception 발생 시점에 Aspect를 실행한다.
이 중에서 가장 많이 사용되는 것은 Around Advice 방식인데, 시점을 다양하게 사용할 수 있기 때문이다.

스프링의 AOP구현

- 프록시를 적용할 클래스에 @Aspect 어노테이션을 붙인다.
- @Pointcut 어노테이션으로 Joinpoint 를 지정한다.
- 공통 기능을 구현한 메소드에 @Around 어노테이션을 지정한다.

1. @Aspect, @Pointcut, @Around를 이용한 AOP 구현

- 스프링AOP 적용 하기 이전 프록시 패턴 코드, 코드의 요점은 ExecutiveTimeCacluator클래스의 생성자에서 구현체를 위임(delegate) 받아 프록시를 구현한다는 점이다.
- 다음은 기존 코드에 어노테이션을 적용했다.

```
@Aspect
public class ExecutiveTimeAspect {

    @Pointcut("execution(public * chap07..*(..))")
    private void publicTarget() {
    }

    @Around("publicTarget()")
    public Object measure(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.nanoTime();
        try {
            Object result = joinPoint.proceed();
            return result;
        } finally {
            long finish = System.nanoTime();
            Signature signature = joinPoint.getSignature();
            System.out.printf("%s.%s(%s) runtime : %s ns\n",
                joinPoint.getTarget().getClass().getSimpleName(),
                signature.getName(), Arrays.toString(joinPoint.getArgs()),
                (finish - start));
        }
    }
```

- @Aspect 어노테이션을 적용한 클래스는 Advice(@Around)와 Pointcut을 제공한다.
- @Pointcut 어노테이션은 공통 기능을 적용할 대상을 지정한다.
- @Around 어노테이션은 publicTarget()의 pointcut에 공통 기능을 적용한다는 의미다.
measure()의 ProceedingJoinPoint 타입 파마리터는 프록시 대상 객체의 메소드를 호출할 때 사용한다.
joinPoint.proceed() 메소드를 호출하면 대상 객체의 메소드가 실행되므로 이 코드 이전과 이후에 공통 기능을 위한 코드를 위치시키면 된다. (기존 코드의 delegate 위치와 같다)

Bean설정

```
@Configuration
@EnableAspectJAutoProxy
public class AppContext {

    @Bean
    public ExecutiveTimeAspect executiveTimeAspect() {
        return new ExecutiveTimeAspect();
    }

    @Bean
    public Calculator calculator() {
        return new ReCalculator();
    }
}
```

- @EnableAspectJAutoProxy 어노테이션을 bean 설정에 붙이면, @Aspect 클래스를 공통 기능으로 사용할 수 있다.
- 스프링은 @Aspect 어노테이션이 붙은 bean 객체를 찾아 @Pointcut 설정과 @Around 설정을 사용한다.

스프링 컨테이너

```
public class MainAspect {

    public static void main(String[] args) {

        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
            AppContext.class);

        Calculator calculator = context.getBean("calculator", Calculator.class);
        long fiveFactorial = calculator.factorial(5);
        System.out.println("calculator.factorial(5) = " + fiveFactorial);
        System.out.println(calculator.getClass().getName());
        context.close();
    }
```

아래는 실행 결과다

```
ReCalculator.factorial([5]) runtime : 22574 ns
calculator.factorial(5) = 120
com.sun.proxy.$Proxy17
```

- 첫번째 줄은 ExecutiveCalculatorAspect클래스의 measure()가 출력한 것이다.
- 세번째 줄은 MainAspect의 main에서 getName()을 출력한 것이다.
- 여기서 AOP를 적용하지 않으면 $Proxy17 대신 ReCalculator를 반환한다. (ExecutiveTimeAspect bean설정 주석처리)

```
calculator.factorial(5) = 120
chap07.ReCalculator
```

ProceedingJoinPoint의 메소드

- Around Advice 방식에서 사용할 공통 기능 메소드는 대부분 파라미터로 전달받은 ProceedingJoinPoint의 proceed()메소드만 호출하면 된다.

ProceedingJoinPoint 인터페이스에서 제공하는 메소드

- Signature getSignature(): 호출 되는 메소드에 대한 정보를 구한다.
- Object getTarget(): 대상 객체를 구한다.
- Object[] getArgs(): 파라미터 목록을 구한다.

org.aspectj.lang.Signature 인터페이스에서 제공하는 메소드

- String getName(): 호출되는 메소드의 이름을 구한다.
- String toLongString(): 호출되는 메소드의 모든 정보를 구한다.
- String toShortString(): 호출되는 메소드를 축약한다. (이름만)

스프링에서 프록시를 생성할 때

스프링에서 에서 다음과 같이 ReCalculator를 사용한다.

```
// 스프링 컨테이너
Calculator calculator = context.getBean("calculator", Calculator.class);

// bean  설정
@Bean
public Calculator calculator() {
    return new ReCalculator();
}
```

- ReCalculator를 사용하는데 Calculator 타입을 사용한다. 이것을 ReCalculator를 사용하도록 바꾸면 Expection이 발생한다.
- 이유는 런타임에 생성한 프록시 객체인 $Proxy17도 ReCalculator구현체가 상속받는 Calculator인터페이스를 상속받기 때문이다.

bean 객체가 인터페이스를 상속할 때 인터페이스가 아닌 구현체를 이용해서 프록시를 생성하고 싶다면 다음과 같이 하면된다.

```
// 스프링 컨테이너
AnnotationConfigApplicationContext context =
    new AnnotationConfigApplicationContext(AppContext.class);

ReCalculator calculator = context.getBean("calculator", ReCalculator.class);

// bean 설정
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppContext {
//...
```

아래는 실행 결과다

```
ReCalculator.factorial([5]) runtime : 15285343 ns
calculator.factorial(5) = 120
chap07.ReCalculator$$EnhancerBySpringCGLIB$$7bd3a4d7
```

ReCalculator를 받는다.
